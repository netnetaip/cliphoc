import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, t as text, a as space, o as svg_element, f as claim_element, g as children, h as claim_text, b as detach_dev, c as claim_space, j as attr_dev, k as add_location, l as insert_dev, m as append_dev, p as listen_dev, r as is_function, u as prop_dev, n as noop, w as run_all, x as not_equal, y as set_data_dev, z as create_component, q as query_selector_all, A as claim_component, B as mount_component, C as transition_in, D as add_render_callback, E as create_in_transition, F as transition_out, G as destroy_component, H as set_style } from './client.e78f111e.js';
import { f as fly } from './index.ff7bd4a9.js';

/* src/components/Button.svelte generated by Svelte v3.24.1 */

const file = "src/components/Button.svelte";

function create_fragment(ctx) {
	let div;
	let a;
	let t0;
	let t1;
	let label;
	let input;
	let input_value_value;
	let t2;
	let svg;
	let path;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			a = element("a");
			t0 = text("Open map");
			t1 = space();
			label = element("label");
			input = element("input");
			t2 = space();
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			a = claim_element(div_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, "Open map");
			a_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			label = claim_element(div_nodes, "LABEL", { class: true });
			var label_nodes = children(label);

			input = claim_element(label_nodes, "INPUT", {
				type: true,
				value: true,
				name: true,
				"aria-pressed": true,
				class: true
			});

			t2 = claim_space(label_nodes);

			svg = claim_element(
				label_nodes,
				"svg",
				{
					xmlns: true,
					width: true,
					height: true,
					viewBox: true,
					fill: true,
					stroke: true,
					"stroke-width": true,
					"stroke-linecap": true,
					"stroke-linejoin": true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			path = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			label_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", /*link*/ ctx[2]);
			attr_dev(a, "class", "svelte-1nryng2");
			add_location(a, file, 112, 1, 2297);
			attr_dev(input, "type", "checkbox");
			input.__value = input_value_value = /*adhoc*/ ctx[1].id;
			input.value = input.__value;
			attr_dev(input, "name", "save");
			attr_dev(input, "aria-pressed", "false");
			attr_dev(input, "class", "svelte-1nryng2");
			add_location(input, file, 114, 2, 2336);
			attr_dev(path, "d", "M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z");
			add_location(path, file, 122, 179, 2692);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "24");
			attr_dev(svg, "height", "24");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "stroke", "#000000");
			attr_dev(svg, "stroke-width", "2");
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			attr_dev(svg, "class", "svelte-1nryng2");
			add_location(svg, file, 122, 3, 2516);
			attr_dev(label, "class", "svelte-1nryng2");
			add_location(label, file, 113, 1, 2326);
			attr_dev(div, "class", "svelte-1nryng2");
			add_location(div, file, 111, 0, 2290);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, a);
			append_dev(a, t0);
			append_dev(div, t1);
			append_dev(div, label);
			append_dev(label, input);
			input.checked = /*state*/ ctx[0];
			append_dev(label, t2);
			append_dev(label, svg);
			append_dev(svg, path);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_handler*/ ctx[4], false, false, false),
					listen_dev(
						input,
						"click",
						function () {
							if (is_function(/*pin*/ ctx[3])) /*pin*/ ctx[3].apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(input, "change", /*input_change_handler*/ ctx[5])
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (dirty & /*link*/ 4) {
				attr_dev(a, "href", /*link*/ ctx[2]);
			}

			if (dirty & /*adhoc*/ 2 && input_value_value !== (input_value_value = /*adhoc*/ ctx[1].id)) {
				prop_dev(input, "__value", input_value_value);
				input.value = input.__value;
			}

			if (dirty & /*state*/ 1) {
				input.checked = /*state*/ ctx[0];
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { adhoc } = $$props;
	let { link } = $$props;
	let { state = false } = $$props;
	const writable_props = ["adhoc", "link", "state"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Button> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Button", $$slots, []);
	const input_handler = () => navigator.vibrate(10);

	function input_change_handler() {
		state = this.checked;
		($$invalidate(0, state), $$invalidate(1, adhoc));
	}

	$$self.$$set = $$props => {
		if ("adhoc" in $$props) $$invalidate(1, adhoc = $$props.adhoc);
		if ("link" in $$props) $$invalidate(2, link = $$props.link);
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
	};

	$$self.$capture_state = () => ({ adhoc, link, state, pin });

	$$self.$inject_state = $$props => {
		if ("adhoc" in $$props) $$invalidate(1, adhoc = $$props.adhoc);
		if ("link" in $$props) $$invalidate(2, link = $$props.link);
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
		if ("pin" in $$props) $$invalidate(3, pin = $$props.pin);
	};

	let pin;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*adhoc*/ 2) {
			// Check Local Storage
			 (async () => {
				if (typeof window !== "undefined") {
					if (localStorage.getItem(adhoc.id, "Saved")) {
						return $$invalidate(0, state = true);
					} else {
						return $$invalidate(0, state = false);
					}
				}
			})();
		}

		if ($$self.$$.dirty & /*adhoc*/ 2) {
			// Mark Checkbox
			 $$invalidate(3, pin = async () => {
				if (!localStorage.getItem(adhoc.id)) {
					return localStorage.setItem(adhoc.id, "Saved");
				} else {
					return localStorage.removeItem(adhoc.id, "Saved");
				}
			});
		}
	};

	return [state, adhoc, link, pin, input_handler, input_change_handler];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { adhoc: 1, link: 2, state: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*adhoc*/ ctx[1] === undefined && !("adhoc" in props)) {
			console.warn("<Button> was created without expected prop 'adhoc'");
		}

		if (/*link*/ ctx[2] === undefined && !("link" in props)) {
			console.warn("<Button> was created without expected prop 'link'");
		}
	}

	get adhoc() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set adhoc(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get link() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set link(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get state() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set state(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/locations/[uid].svelte generated by Svelte v3.24.1 */
const file$1 = "src/routes/locations/[uid].svelte";

// (88:3) {:else}
function create_else_block(ctx) {
	let em;
	let t0;
	let t1_value = /*adhoc*/ ctx[0].type + "";
	let t1;

	const block = {
		c: function create() {
			em = element("em");
			t0 = text("#");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			em = claim_element(nodes, "EM", { style: true });
			var em_nodes = children(em);
			t0 = claim_text(em_nodes, "#");
			t1 = claim_text(em_nodes, t1_value);
			em_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(em, "color", "var(--col-seco)");
			add_location(em, file$1, 88, 4, 1834);
		},
		m: function mount(target, anchor) {
			insert_dev(target, em, anchor);
			append_dev(em, t0);
			append_dev(em, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*adhoc*/ 1 && t1_value !== (t1_value = /*adhoc*/ ctx[0].type + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(em);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(88:3) {:else}",
		ctx
	});

	return block;
}

// (86:3) {#if adhoc.type === "designer"}
function create_if_block_1(ctx) {
	let em;
	let t0;
	let t1_value = /*adhoc*/ ctx[0].type + "";
	let t1;

	const block = {
		c: function create() {
			em = element("em");
			t0 = text("#");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			em = claim_element(nodes, "EM", { style: true });
			var em_nodes = children(em);
			t0 = claim_text(em_nodes, "#");
			t1 = claim_text(em_nodes, t1_value);
			em_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(em, "color", "var(--col-tert)");
			add_location(em, file$1, 86, 4, 1765);
		},
		m: function mount(target, anchor) {
			insert_dev(target, em, anchor);
			append_dev(em, t0);
			append_dev(em, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*adhoc*/ 1 && t1_value !== (t1_value = /*adhoc*/ ctx[0].type + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(em);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(86:3) {#if adhoc.type === \\\"designer\\\"}",
		ctx
	});

	return block;
}

// (125:3) {#if adhoc.phone != null}
function create_if_block(ctx) {
	let t_value = /*adhoc*/ ctx[0].phone + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*adhoc*/ 1 && t_value !== (t_value = /*adhoc*/ ctx[0].phone + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(125:3) {#if adhoc.phone != null}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let title_value;
	let t0;
	let div;
	let section;
	let header;
	let t1;
	let h2;
	let t2_value = /*adhoc*/ ctx[0].title + "";
	let t2;
	let t3;
	let dl;
	let dt;
	let t4_value = /*adhoc*/ ctx[0].author + "";
	let t4;
	let dd;
	let t5_value = /*adhoc*/ ctx[0].city + "";
	let t5;
	let t6;
	let t7_value = /*adhoc*/ ctx[0].country + "";
	let t7;
	let t8;
	let p;
	let t9;
	let t10;
	let hr;
	let t11;
	let address0;
	let t12_value = /*adhoc*/ ctx[0].email + "";
	let t12;
	let t13;
	let address1;
	let t14;
	let table;
	let tr0;
	let th0;
	let t15;
	let t16;
	let td0;
	let t17_value = /*adhoc*/ ctx[0].city + "";
	let t17;
	let t18;
	let tr1;
	let th1;
	let t19;
	let t20;
	let td1;
	let t21_value = /*adhoc*/ ctx[0].country + "";
	let t21;
	let t22;
	let button;
	let div_intro;
	let current;
	document.title = title_value = /*adhoc*/ ctx[0].title;

	function select_block_type(ctx, dirty) {
		if (/*adhoc*/ ctx[0].type === "designer") return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*adhoc*/ ctx[0].phone != null && create_if_block(ctx);

	button = new Button({
			props: {
				adhoc: /*adhoc*/ ctx[0],
				link: /*link*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			div = element("div");
			section = element("section");
			header = element("header");
			if_block0.c();
			t1 = space();
			h2 = element("h2");
			t2 = text(t2_value);
			t3 = space();
			dl = element("dl");
			dt = element("dt");
			t4 = text(t4_value);
			dd = element("dd");
			t5 = text(t5_value);
			t6 = text(", ");
			t7 = text(t7_value);
			t8 = space();
			p = element("p");
			t9 = text("Voluptate ea aliquip nisi consequat ipsum ipsum enim non Lorem.\n\t\t\tNulla ullamco ut nostrud Lorem quis officia dolore adipisicing.\n\t\t\tEx Lorem officia reprehenderit velit aute voluptate aliquip\n\t\t\texercitation in. Nulla anim ex amet do aliqua sunt laborum anim\n\t\t\tad. Cupidatat voluptate deserunt sint elit ipsum aliquip aliquip\n\t\t\texcepteur. Elit irure sunt eu proident sit. Consectetur in\n\t\t\tconsectetur ex sint exercitation enim amet laboris nisi. Cillum\n\t\t\tesse non ut id quis aliquip duis amet officia eu irure aliquip\n\t\t\tsint quis. Magna voluptate dolor in esse aliqua esse adipisicing\n\t\t\tcommodo. Amet laboris id sit pariatur labore nostrud laborum\n\t\t\tvelit exercitation ea veniam minim mollit duis. Voluptate ea aliquip nisi consequat ipsum ipsum enim non Lorem.\n\t\t\tNulla ullamco ut nostrud Lorem quis officia dolore adipisicing.\n\t\t\tEx Lorem officia reprehenderit velit aute voluptate aliquip\n\t\t\texercitation in. Nulla anim ex amet do aliqua sunt laborum anim\n\t\t\tad. Cupidatat voluptate deserunt sint elit ipsum aliquip aliquip\n\t\t\texcepteur. Elit irure sunt eu proident sit. Consectetur in\n\t\t\tconsectetur ex sint exercitation enim amet laboris nisi. Cillum\n\t\t\tesse non ut id quis aliquip duis amet officia eu irure aliquip\n\t\t\tsint quis. Magna voluptate dolor in esse aliqua esse adipisicing\n\t\t\tcommodo. Amet laboris id sit pariatur labore nostrud laborum\n\t\t\tvelit exercitation ea veniam minim mollit duis.");
			t10 = space();
			hr = element("hr");
			t11 = space();
			address0 = element("address");
			t12 = text(t12_value);
			t13 = space();
			address1 = element("address");
			if (if_block1) if_block1.c();
			t14 = space();
			table = element("table");
			tr0 = element("tr");
			th0 = element("th");
			t15 = text("City");
			t16 = space();
			td0 = element("td");
			t17 = text(t17_value);
			t18 = space();
			tr1 = element("tr");
			th1 = element("th");
			t19 = text("Country");
			t20 = space();
			td1 = element("td");
			t21 = text(t21_value);
			t22 = space();
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-w6u6cv\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			section = claim_element(div_nodes, "SECTION", {});
			var section_nodes = children(section);
			header = claim_element(section_nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			if_block0.l(header_nodes);
			t1 = claim_space(header_nodes);
			h2 = claim_element(header_nodes, "H2", {});
			var h2_nodes = children(h2);
			t2 = claim_text(h2_nodes, t2_value);
			h2_nodes.forEach(detach_dev);
			t3 = claim_space(header_nodes);
			dl = claim_element(header_nodes, "DL", {});
			var dl_nodes = children(dl);
			dt = claim_element(dl_nodes, "DT", { class: true });
			var dt_nodes = children(dt);
			t4 = claim_text(dt_nodes, t4_value);
			dt_nodes.forEach(detach_dev);
			dd = claim_element(dl_nodes, "DD", { class: true });
			var dd_nodes = children(dd);
			t5 = claim_text(dd_nodes, t5_value);
			t6 = claim_text(dd_nodes, ", ");
			t7 = claim_text(dd_nodes, t7_value);
			dd_nodes.forEach(detach_dev);
			dl_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			t8 = claim_space(section_nodes);
			p = claim_element(section_nodes, "P", { class: true });
			var p_nodes = children(p);
			t9 = claim_text(p_nodes, "Voluptate ea aliquip nisi consequat ipsum ipsum enim non Lorem.\n\t\t\tNulla ullamco ut nostrud Lorem quis officia dolore adipisicing.\n\t\t\tEx Lorem officia reprehenderit velit aute voluptate aliquip\n\t\t\texercitation in. Nulla anim ex amet do aliqua sunt laborum anim\n\t\t\tad. Cupidatat voluptate deserunt sint elit ipsum aliquip aliquip\n\t\t\texcepteur. Elit irure sunt eu proident sit. Consectetur in\n\t\t\tconsectetur ex sint exercitation enim amet laboris nisi. Cillum\n\t\t\tesse non ut id quis aliquip duis amet officia eu irure aliquip\n\t\t\tsint quis. Magna voluptate dolor in esse aliqua esse adipisicing\n\t\t\tcommodo. Amet laboris id sit pariatur labore nostrud laborum\n\t\t\tvelit exercitation ea veniam minim mollit duis. Voluptate ea aliquip nisi consequat ipsum ipsum enim non Lorem.\n\t\t\tNulla ullamco ut nostrud Lorem quis officia dolore adipisicing.\n\t\t\tEx Lorem officia reprehenderit velit aute voluptate aliquip\n\t\t\texercitation in. Nulla anim ex amet do aliqua sunt laborum anim\n\t\t\tad. Cupidatat voluptate deserunt sint elit ipsum aliquip aliquip\n\t\t\texcepteur. Elit irure sunt eu proident sit. Consectetur in\n\t\t\tconsectetur ex sint exercitation enim amet laboris nisi. Cillum\n\t\t\tesse non ut id quis aliquip duis amet officia eu irure aliquip\n\t\t\tsint quis. Magna voluptate dolor in esse aliqua esse adipisicing\n\t\t\tcommodo. Amet laboris id sit pariatur labore nostrud laborum\n\t\t\tvelit exercitation ea veniam minim mollit duis.");
			p_nodes.forEach(detach_dev);
			t10 = claim_space(section_nodes);
			hr = claim_element(section_nodes, "HR", {});
			t11 = claim_space(section_nodes);
			address0 = claim_element(section_nodes, "ADDRESS", { class: true });
			var address0_nodes = children(address0);
			t12 = claim_text(address0_nodes, t12_value);
			address0_nodes.forEach(detach_dev);
			t13 = claim_space(section_nodes);
			address1 = claim_element(section_nodes, "ADDRESS", { class: true });
			var address1_nodes = children(address1);
			if (if_block1) if_block1.l(address1_nodes);
			address1_nodes.forEach(detach_dev);
			t14 = claim_space(section_nodes);
			table = claim_element(section_nodes, "TABLE", {});
			var table_nodes = children(table);
			tr0 = claim_element(table_nodes, "TR", {});
			var tr0_nodes = children(tr0);
			th0 = claim_element(tr0_nodes, "TH", {});
			var th0_nodes = children(th0);
			t15 = claim_text(th0_nodes, "City");
			th0_nodes.forEach(detach_dev);
			t16 = claim_space(tr0_nodes);
			td0 = claim_element(tr0_nodes, "TD", {});
			var td0_nodes = children(td0);
			t17 = claim_text(td0_nodes, t17_value);
			td0_nodes.forEach(detach_dev);
			tr0_nodes.forEach(detach_dev);
			t18 = claim_space(table_nodes);
			tr1 = claim_element(table_nodes, "TR", {});
			var tr1_nodes = children(tr1);
			th1 = claim_element(tr1_nodes, "TH", {});
			var th1_nodes = children(th1);
			t19 = claim_text(th1_nodes, "Country");
			th1_nodes.forEach(detach_dev);
			t20 = claim_space(tr1_nodes);
			td1 = claim_element(tr1_nodes, "TD", {});
			var td1_nodes = children(td1);
			t21 = claim_text(td1_nodes, t21_value);
			td1_nodes.forEach(detach_dev);
			tr1_nodes.forEach(detach_dev);
			table_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			t22 = claim_space(div_nodes);
			claim_component(button.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h2, file$1, 90, 3, 1900);
			attr_dev(dt, "class", "svelte-1vditmf");
			add_location(dt, file$1, 92, 4, 1935);
			attr_dev(dd, "class", "svelte-1vditmf");
			add_location(dd, file$1, 93, 4, 1963);
			add_location(dl, file$1, 91, 3, 1926);
			attr_dev(header, "class", "svelte-1vditmf");
			add_location(header, file$1, 84, 2, 1717);
			attr_dev(p, "class", "svelte-1vditmf");
			add_location(p, file$1, 96, 2, 2025);
			add_location(hr, file$1, 119, 2, 3455);
			attr_dev(address0, "class", "svelte-1vditmf");
			add_location(address0, file$1, 120, 2, 3462);
			attr_dev(address1, "class", "svelte-1vditmf");
			add_location(address1, file$1, 123, 2, 3504);
			add_location(th0, file$1, 130, 4, 3605);
			add_location(td0, file$1, 131, 4, 3623);
			add_location(tr0, file$1, 129, 3, 3596);
			add_location(th1, file$1, 134, 4, 3666);
			add_location(td1, file$1, 135, 4, 3687);
			add_location(tr1, file$1, 133, 3, 3657);
			add_location(table, file$1, 128, 2, 3585);
			add_location(section, file$1, 83, 1, 1705);
			attr_dev(div, "class", "svelte-1vditmf");
			add_location(div, file$1, 82, 0, 1652);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, section);
			append_dev(section, header);
			if_block0.m(header, null);
			append_dev(header, t1);
			append_dev(header, h2);
			append_dev(h2, t2);
			append_dev(header, t3);
			append_dev(header, dl);
			append_dev(dl, dt);
			append_dev(dt, t4);
			append_dev(dl, dd);
			append_dev(dd, t5);
			append_dev(dd, t6);
			append_dev(dd, t7);
			append_dev(section, t8);
			append_dev(section, p);
			append_dev(p, t9);
			append_dev(section, t10);
			append_dev(section, hr);
			append_dev(section, t11);
			append_dev(section, address0);
			append_dev(address0, t12);
			append_dev(section, t13);
			append_dev(section, address1);
			if (if_block1) if_block1.m(address1, null);
			append_dev(section, t14);
			append_dev(section, table);
			append_dev(table, tr0);
			append_dev(tr0, th0);
			append_dev(th0, t15);
			append_dev(tr0, t16);
			append_dev(tr0, td0);
			append_dev(td0, t17);
			append_dev(table, t18);
			append_dev(table, tr1);
			append_dev(tr1, th1);
			append_dev(th1, t19);
			append_dev(tr1, t20);
			append_dev(tr1, td1);
			append_dev(td1, t21);
			append_dev(div, t22);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*adhoc*/ 1) && title_value !== (title_value = /*adhoc*/ ctx[0].title)) {
				document.title = title_value;
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(header, t1);
				}
			}

			if ((!current || dirty & /*adhoc*/ 1) && t2_value !== (t2_value = /*adhoc*/ ctx[0].title + "")) set_data_dev(t2, t2_value);
			if ((!current || dirty & /*adhoc*/ 1) && t4_value !== (t4_value = /*adhoc*/ ctx[0].author + "")) set_data_dev(t4, t4_value);
			if ((!current || dirty & /*adhoc*/ 1) && t5_value !== (t5_value = /*adhoc*/ ctx[0].city + "")) set_data_dev(t5, t5_value);
			if ((!current || dirty & /*adhoc*/ 1) && t7_value !== (t7_value = /*adhoc*/ ctx[0].country + "")) set_data_dev(t7, t7_value);
			if ((!current || dirty & /*adhoc*/ 1) && t12_value !== (t12_value = /*adhoc*/ ctx[0].email + "")) set_data_dev(t12, t12_value);

			if (/*adhoc*/ ctx[0].phone != null) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(address1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if ((!current || dirty & /*adhoc*/ 1) && t17_value !== (t17_value = /*adhoc*/ ctx[0].city + "")) set_data_dev(t17, t17_value);
			if ((!current || dirty & /*adhoc*/ 1) && t21_value !== (t21_value = /*adhoc*/ ctx[0].country + "")) set_data_dev(t21, t21_value);
			const button_changes = {};
			if (dirty & /*adhoc*/ 1) button_changes.adhoc = /*adhoc*/ ctx[0];
			if (dirty & /*link*/ 2) button_changes.link = /*link*/ ctx[1];
			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);

			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fly, { duration: 320, y: 40, opacity: 1 });
					div_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if_block0.d();
			if (if_block1) if_block1.d();
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload(page, session) {
	// URL + ID
	const { uid } = page.params;

	const url = "https://6016e904f534300017a4509d.mockapi.io/board/" + uid;

	// Fetch
	const res = await this.fetch(url);

	// Validate
	if (res.status === 200) {
		const adhoc = await res.json();
		return { adhoc };
	}

	// Error
	this.error(500, "Problems with server. Be right back soon ;)");
}

function instance$1($$self, $$props, $$invalidate) {
	let { adhoc } = $$props;
	let { link = "javascript:;" } = $$props;

	// Back
	const historyback = () => {
		if (typeof window !== "undefined") {
			window.history.back();
		}
	};

	const writable_props = ["adhoc", "link"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<U5Buidu5D> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("U5Buidu5D", $$slots, []);

	$$self.$$set = $$props => {
		if ("adhoc" in $$props) $$invalidate(0, adhoc = $$props.adhoc);
		if ("link" in $$props) $$invalidate(1, link = $$props.link);
	};

	$$self.$capture_state = () => ({
		preload,
		fly,
		Button,
		adhoc,
		link,
		historyback
	});

	$$self.$inject_state = $$props => {
		if ("adhoc" in $$props) $$invalidate(0, adhoc = $$props.adhoc);
		if ("link" in $$props) $$invalidate(1, link = $$props.link);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [adhoc, link];
}

class U5Buidu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, not_equal, { adhoc: 0, link: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Buidu5D",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*adhoc*/ ctx[0] === undefined && !("adhoc" in props)) {
			console.warn("<U5Buidu5D> was created without expected prop 'adhoc'");
		}
	}

	get adhoc() {
		throw new Error("<U5Buidu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set adhoc(value) {
		throw new Error("<U5Buidu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get link() {
		throw new Error("<U5Buidu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set link(value) {
		throw new Error("<U5Buidu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default U5Buidu5D;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiW3VpZF0uNzNiYWM3NTYuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0J1dHRvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2xvY2F0aW9ucy9bdWlkXS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cblx0Ly8gRXhwb3J0ZWRcblx0ZXhwb3J0IGxldCBhZGhvYztcblx0ZXhwb3J0IGxldCBsaW5rO1xuXHRleHBvcnQgbGV0IHN0YXRlID0gZmFsc2U7XG5cblx0Ly8gQ2hlY2sgTG9jYWwgU3RvcmFnZVxuXHQkOiAoYXN5bmMoKSA9PiB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShhZGhvYy5pZCwgXCJTYXZlZFwiKSkge1xuXHRcdFx0XHRyZXR1cm4gc3RhdGUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHN0YXRlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KSgpO1xuXG5cdC8vIE1hcmsgQ2hlY2tib3hcblx0JDogcGluID0gYXN5bmMgKCkgPT4ge1xuXHRcdGlmICghbG9jYWxTdG9yYWdlLmdldEl0ZW0oYWRob2MuaWQpKSB7XG5cdFx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oYWRob2MuaWQsIFwiU2F2ZWRcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShhZGhvYy5pZCwgXCJTYXZlZFwiKTtcblx0XHR9XG5cdH07XG48L3NjcmlwdD5cblxuPCEtLSBDU1MgLS0+XG48c3R5bGU+XG5cdGRpdiB7XG5cdFx0LyogRGlzcGxheSAqL1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IHJvdztcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cdFx0LyogU2l6aW5nICovXG5cdFx0bWluLWhlaWdodDogY2FsYygxMHZoICsgKHZhcigtLXB0KSAqIDIpKTtcblx0XHRtYXgtaGVpZ2h0OiBjYWxjKDEwdmggKyAodmFyKC0tcHQpICogMikpO1xuXHRcdGhlaWdodDogY2FsYygxMHZoICsgKHZhcigtLXB0KSAqIDIpKTtcblx0XHRtaW4td2lkdGg6IDEwMCU7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdC8qIFBvc2l0aW9uICovXG5cdFx0cG9zaXRpb246IHN0aWNreTtcblx0XHRwb3NpdGlvbjogLXdlYmtpdC1zdGlja3k7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdC8qIFJlc3QgKi9cblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2wtcHJpbWUpO1xuXHRcdGJvcmRlci10b3A6IDJweCBzb2xpZCB2YXIoLS1jb2wtcHJpbWVsaWdodCk7XG5cdFx0cGFkZGluZzogY2FsYyh2YXIoLS1wdCkgKiAyKSBjYWxjKHZhcigtLXB0KSAqIDMpO1xuXHR9XG5cdGEsIGxhYmVsIHtcblx0XHQvKiBEaXNwbGF5ICovXG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogcm93O1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0YWxpZ24tY29udGVudDogY2VudGVyO1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHR9XG5cdGEge1xuXHRcdC8qIFNpemluZyAqL1xuXHRcdG1pbi1oZWlnaHQ6IDEwMCU7XG5cdFx0bWF4LWhlaWdodDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0bWluLXdpZHRoOiA3MHZ3O1xuXHRcdG1heC13aWR0aDogNzB2dztcblx0XHR3aWR0aDogMTAwJTtcblx0XHQvKiBSZXN0ICovXG5cdFx0Ym9yZGVyLXJhZGl1czogdmFyKC0tcHQpO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbC1zZWNvKTtcblx0XHRjb2xvcjogdmFyKC0tY29sLXByaW1lKTtcblx0XHRtYXJnaW4tcmlnaHQ6IHZhcigtLXB0KTtcblx0fVxuXHRsYWJlbCB7XG5cdFx0LyogU2l6aW5nICovXG5cdFx0bWluLWhlaWdodDogMTAwJTtcblx0XHRtYXgtaGVpZ2h0OiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRtaW4td2lkdGg6IG5vbmU7XG5cdFx0bWF4LXdpZHRoOiBub25lO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdC8qIFJlc3QgKi9cblx0XHRib3JkZXItcmFkaXVzOiB2YXIoLS1wdCk7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sLXByaW1lbGlnaHQpO1xuXHR9XG5cdGlucHV0W3R5cGU9Y2hlY2tib3hdIHtcblx0XHQtbW96LWFwcGVhcmFuY2U6IG5vbmU7XG5cdFx0LXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuXHRcdGFwcGVhcmFuY2U6IG5vbmU7XG5cdFx0ZGlzcGxheTogbm9uZTtcblx0fVxuXHRpbnB1dFt0eXBlPWNoZWNrYm94XTpjaGVja2VkIH4gc3ZnIHtcblx0XHRmaWxsOiB2YXIoLS1jb2wtYmxhY2spO1xuXHR9XG5cdHN2ZyB7XG4gICAgICAgIC8qIFNpemluZyAqL1xuXHRcdG1pbi1oZWlnaHQ6IGNhbGModmFyKC0tcHQpICogMi41KTtcblx0XHRtYXgtaGVpZ2h0OiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG5cdFx0aGVpZ2h0OiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG5cdFx0bWluLXdpZHRoOiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG5cdFx0bWF4LXdpZHRoOiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG4gICAgICAgIHdpZHRoOiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG4gICAgICAgIC8qIFJlc3QgKi9cbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1jb2wtYmxhY2spO1xuICAgICAgICBzdHJva2Utd2lkdGg6IDI7XG5cdFx0ZmlsbDogbm9uZTtcbiAgICB9XG48L3N0eWxlPlxuXG48IS0tIEhUTUwgLS0+XG48ZGl2PlxuXHQ8YSBocmVmPXtsaW5rfT5PcGVuIG1hcDwvYT5cblx0PGxhYmVsPlxuXHRcdDxpbnB1dFxuXHRcdFx0b246aW5wdXQ9eygpID0+IG5hdmlnYXRvci52aWJyYXRlKDEwKX1cblx0XHRcdG9uOmNsaWNrPXtwaW59IFxuXHRcdFx0YmluZDpjaGVja2VkPXtzdGF0ZX0gXG5cdFx0XHR0eXBlPVwiY2hlY2tib3hcIiBcblx0XHRcdHZhbHVlPXthZGhvYy5pZH0gXG5cdFx0XHRuYW1lPVwic2F2ZVwiIFxuXHRcdFx0YXJpYS1wcmVzc2VkPVwiZmFsc2VcIiAvPlxuXHRcdFx0PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiIzAwMDAwMFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cGF0aCBkPVwiTTE5IDIxbC03LTUtNyA1VjVhMiAyIDAgMCAxIDItMmgxMGEyIDIgMCAwIDEgMiAyelwiPjwvcGF0aD48L3N2Zz5cblx0PC9sYWJlbD5cbjwvZGl2PiIsIjwhLS0gU2VydmVyIC0tPlxuPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG5cdGV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVsb2FkKHBhZ2UsIHNlc3Npb24pIHtcblx0XHQvLyBVUkwgKyBJRFxuXHRcdGNvbnN0IHsgdWlkIH0gPSBwYWdlLnBhcmFtcztcblx0XHRjb25zdCB1cmwgPSBcImh0dHBzOi8vNjAxNmU5MDRmNTM0MzAwMDE3YTQ1MDlkLm1vY2thcGkuaW8vYm9hcmQvXCIgKyB1aWQ7XG5cdFx0Ly8gRmV0Y2hcblx0XHRjb25zdCByZXMgPSBhd2FpdCB0aGlzLmZldGNoKHVybCk7XG5cdFx0Ly8gVmFsaWRhdGVcblx0XHRpZiAocmVzLnN0YXR1cyA9PT0gMjAwKSB7XG5cdFx0XHRjb25zdCBhZGhvYyA9IGF3YWl0IHJlcy5qc29uKCk7XG5cdFx0XHRyZXR1cm4geyBhZGhvYyB9O1xuXHRcdH1cblx0XHQvLyBFcnJvclxuXHRcdHRoaXMuZXJyb3IoNTAwLCBcIlByb2JsZW1zIHdpdGggc2VydmVyLiBCZSByaWdodCBiYWNrIHNvb24gOylcIik7XG5cdH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0PlxuXHRpbXBvcnQgeyBmbHkgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcblx0aW1wb3J0IEJ1dHRvbiBmcm9tIFwiLi4vLi4vY29tcG9uZW50cy9CdXR0b24uc3ZlbHRlXCI7XG5cblx0Ly8gRXhwb3J0ZWRcblx0ZXhwb3J0IGxldCBhZGhvYztcblx0ZXhwb3J0IGxldCBsaW5rID0gXCJqYXZhc2NyaXB0OjtcIjtcblxuXHQvLyBCYWNrXG5cdGNvbnN0IGhpc3RvcnliYWNrID0gKCkgPT4ge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG5cdFx0fVxuXHR9O1xuPC9zY3JpcHQ+XG5cbjwhLS0gU3BlY2lhbCAtLT5cbjxzdmVsdGU6aGVhZD5cblx0PHRpdGxlPnthZGhvYy50aXRsZX08L3RpdGxlPlxuPC9zdmVsdGU6aGVhZD5cbjxzdmVsdGU6b3B0aW9ucyBpbW11dGFibGUgLz5cblxuPCEtLSBDU1MgLS0+XG48c3R5bGU+XG5cdGRpdiB7XG5cdFx0LyogRGlzcGxheSAqL1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG5cdFx0LyogUmVzdCAqL1xuXHRcdHBhZGRpbmctdG9wOiBjYWxjKHZhcigtLXB0KSAqIDEuNSk7XG5cdH1cblx0aGVhZGVyIHtcblx0XHRwYWRkaW5nOiBjYWxjKHZhcigtLXB0KSAqIDMpIGNhbGModmFyKC0tcHQpICogMykgMDtcblx0fVxuXHRwIHtcblx0XHRwYWRkaW5nOiBjYWxjKHZhcigtLXB0KSAqIDMpO1xuXHR9XG5cdHN2ZyB7XG4gICAgICAgIC8qIFNpemluZyAqL1xuXHRcdG1pbi1oZWlnaHQ6IGNhbGModmFyKC0tcHQpICogMi41KTtcblx0XHRtYXgtaGVpZ2h0OiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG5cdFx0aGVpZ2h0OiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG5cdFx0bWluLXdpZHRoOiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG5cdFx0bWF4LXdpZHRoOiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG4gICAgICAgIHdpZHRoOiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG4gICAgICAgIC8qIFJlc3QgKi9cbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1jb2wtYmxhY2spO1xuICAgICAgICBzdHJva2Utd2lkdGg6IDI7XG5cdFx0ZmlsbDogbm9uZTtcblx0XHRtYXJnaW4tcmlnaHQ6IHZhcigtLXB0KTtcblx0fVxuXHQvKiBGb250cyAqL1xuXHRkdCwgcCwgYWRkcmVzcyB7XG5cdFx0Zm9udC1zaXplOiAxcmVtO1xuXHR9XG5cdGRkIHtcblx0XHRmb250LXNpemU6IC45cmVtO1xuXHR9XG48L3N0eWxlPlxuXG48IS0tIEhUTUwgLS0+XG48ZGl2IGluOmZseT17eyBkdXJhdGlvbjogMzIwLCB5OiA0MCwgb3BhY2l0eTogMSB9fT5cblx0PHNlY3Rpb24+XG5cdFx0PGhlYWRlcj5cblx0XHRcdHsjaWYgYWRob2MudHlwZSA9PT0gXCJkZXNpZ25lclwifVxuXHRcdFx0XHQ8ZW0gc3R5bGU9XCJjb2xvcjogdmFyKC0tY29sLXRlcnQpXCI+I3thZGhvYy50eXBlfTwvZW0+XG5cdFx0XHR7OmVsc2V9XG5cdFx0XHRcdDxlbSBzdHlsZT1cImNvbG9yOiB2YXIoLS1jb2wtc2VjbylcIj4je2FkaG9jLnR5cGV9PC9lbT5cblx0XHRcdHsvaWZ9XG5cdFx0XHQ8aDI+e2FkaG9jLnRpdGxlfTwvaDI+XG5cdFx0XHQ8ZGw+XG5cdFx0XHRcdDxkdD57YWRob2MuYXV0aG9yfTwvZHQ+XG5cdFx0XHRcdDxkZD57YWRob2MuY2l0eX0sIHthZGhvYy5jb3VudHJ5fTwvZGQ+XG5cdFx0XHQ8L2RsPlxuXHRcdDwvaGVhZGVyPlxuXHRcdDxwPlxuXHRcdFx0Vm9sdXB0YXRlIGVhIGFsaXF1aXAgbmlzaSBjb25zZXF1YXQgaXBzdW0gaXBzdW0gZW5pbSBub24gTG9yZW0uXG5cdFx0XHROdWxsYSB1bGxhbWNvIHV0IG5vc3RydWQgTG9yZW0gcXVpcyBvZmZpY2lhIGRvbG9yZSBhZGlwaXNpY2luZy5cblx0XHRcdEV4IExvcmVtIG9mZmljaWEgcmVwcmVoZW5kZXJpdCB2ZWxpdCBhdXRlIHZvbHVwdGF0ZSBhbGlxdWlwXG5cdFx0XHRleGVyY2l0YXRpb24gaW4uIE51bGxhIGFuaW0gZXggYW1ldCBkbyBhbGlxdWEgc3VudCBsYWJvcnVtIGFuaW1cblx0XHRcdGFkLiBDdXBpZGF0YXQgdm9sdXB0YXRlIGRlc2VydW50IHNpbnQgZWxpdCBpcHN1bSBhbGlxdWlwIGFsaXF1aXBcblx0XHRcdGV4Y2VwdGV1ci4gRWxpdCBpcnVyZSBzdW50IGV1IHByb2lkZW50IHNpdC4gQ29uc2VjdGV0dXIgaW5cblx0XHRcdGNvbnNlY3RldHVyIGV4IHNpbnQgZXhlcmNpdGF0aW9uIGVuaW0gYW1ldCBsYWJvcmlzIG5pc2kuIENpbGx1bVxuXHRcdFx0ZXNzZSBub24gdXQgaWQgcXVpcyBhbGlxdWlwIGR1aXMgYW1ldCBvZmZpY2lhIGV1IGlydXJlIGFsaXF1aXBcblx0XHRcdHNpbnQgcXVpcy4gTWFnbmEgdm9sdXB0YXRlIGRvbG9yIGluIGVzc2UgYWxpcXVhIGVzc2UgYWRpcGlzaWNpbmdcblx0XHRcdGNvbW1vZG8uIEFtZXQgbGFib3JpcyBpZCBzaXQgcGFyaWF0dXIgbGFib3JlIG5vc3RydWQgbGFib3J1bVxuXHRcdFx0dmVsaXQgZXhlcmNpdGF0aW9uIGVhIHZlbmlhbSBtaW5pbSBtb2xsaXQgZHVpcy4gVm9sdXB0YXRlIGVhIGFsaXF1aXAgbmlzaSBjb25zZXF1YXQgaXBzdW0gaXBzdW0gZW5pbSBub24gTG9yZW0uXG5cdFx0XHROdWxsYSB1bGxhbWNvIHV0IG5vc3RydWQgTG9yZW0gcXVpcyBvZmZpY2lhIGRvbG9yZSBhZGlwaXNpY2luZy5cblx0XHRcdEV4IExvcmVtIG9mZmljaWEgcmVwcmVoZW5kZXJpdCB2ZWxpdCBhdXRlIHZvbHVwdGF0ZSBhbGlxdWlwXG5cdFx0XHRleGVyY2l0YXRpb24gaW4uIE51bGxhIGFuaW0gZXggYW1ldCBkbyBhbGlxdWEgc3VudCBsYWJvcnVtIGFuaW1cblx0XHRcdGFkLiBDdXBpZGF0YXQgdm9sdXB0YXRlIGRlc2VydW50IHNpbnQgZWxpdCBpcHN1bSBhbGlxdWlwIGFsaXF1aXBcblx0XHRcdGV4Y2VwdGV1ci4gRWxpdCBpcnVyZSBzdW50IGV1IHByb2lkZW50IHNpdC4gQ29uc2VjdGV0dXIgaW5cblx0XHRcdGNvbnNlY3RldHVyIGV4IHNpbnQgZXhlcmNpdGF0aW9uIGVuaW0gYW1ldCBsYWJvcmlzIG5pc2kuIENpbGx1bVxuXHRcdFx0ZXNzZSBub24gdXQgaWQgcXVpcyBhbGlxdWlwIGR1aXMgYW1ldCBvZmZpY2lhIGV1IGlydXJlIGFsaXF1aXBcblx0XHRcdHNpbnQgcXVpcy4gTWFnbmEgdm9sdXB0YXRlIGRvbG9yIGluIGVzc2UgYWxpcXVhIGVzc2UgYWRpcGlzaWNpbmdcblx0XHRcdGNvbW1vZG8uIEFtZXQgbGFib3JpcyBpZCBzaXQgcGFyaWF0dXIgbGFib3JlIG5vc3RydWQgbGFib3J1bVxuXHRcdFx0dmVsaXQgZXhlcmNpdGF0aW9uIGVhIHZlbmlhbSBtaW5pbSBtb2xsaXQgZHVpcy5cblx0XHQ8L3A+XG5cdFx0PGhyPlxuXHRcdDxhZGRyZXNzPlxuXHRcdFx0e2FkaG9jLmVtYWlsfVxuXHRcdDwvYWRkcmVzcz5cblx0XHQ8YWRkcmVzcz5cblx0XHRcdHsjaWYgYWRob2MucGhvbmUgIT0gbnVsbH1cblx0XHRcdFx0e2FkaG9jLnBob25lfVxuXHRcdFx0ey9pZn1cblx0XHQ8L2FkZHJlc3M+XG5cdFx0PHRhYmxlPlxuXHRcdFx0PHRyPlxuXHRcdFx0XHQ8dGg+Q2l0eTwvdGg+XG5cdFx0XHRcdDx0ZD57YWRob2MuY2l0eX08L3RkPlxuXHRcdFx0PC90cj5cblx0XHRcdDx0cj5cblx0XHRcdFx0PHRoPkNvdW50cnk8L3RoPlxuXHRcdFx0XHQ8dGQ+e2FkaG9jLmNvdW50cnl9PC90ZD5cblx0XHRcdDwvdHI+XG5cdFx0PC90YWJsZT5cblx0PC9zZWN0aW9uPlxuXHQ8IS0tIENUQSdzIC0tPlxuXHQ8QnV0dG9uIHthZGhvY30ge2xpbmt9Lz5cbjwvZGl2PlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0NBZ0hVLEdBQUk7Ozs7aURBT0osR0FBSyxJQUFDLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBRkQsR0FBSzs7Ozs7Ozs7Ozs7OytCQURULEdBQUcsY0FBSCxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7O2lDQUpOLEdBQUk7OzttRkFPSixHQUFLLElBQUMsRUFBRTs7Ozs7OzhCQUZELEdBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQW5IVixLQUFLO09BQ0wsSUFBSTtPQUNKLEtBQUssR0FBRyxLQUFLOzs7Ozs7Ozs7NkJBK0dOLFNBQVMsQ0FBQyxPQUFPLENBQUMsRUFBRTs7O0VBRXRCLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBN0dULE1BQU0sS0FBSyxXQUFXO1NBQzVCLFlBQVksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxPQUFPOzZCQUNsQyxLQUFLLEdBQUcsSUFBSTs7NkJBRVosS0FBSyxHQUFHLEtBQUs7Ozs7Ozs7O29CQU1wQixHQUFHO1NBQ0EsWUFBWSxDQUFDLE9BQU8s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
