import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, t as text, a as space, o as svg_element, f as claim_element, g as children, h as claim_text, b as detach_dev, c as claim_space, j as attr_dev, k as add_location, l as insert_dev, m as append_dev, p as listen_dev, r as is_function, u as prop_dev, n as noop, w as run_all, x as not_equal, y as validate_each_argument, z as set_data_dev, A as xlink_attr, B as create_component, q as query_selector_all, C as claim_component, D as mount_component, E as transition_in, F as add_render_callback, G as create_in_transition, H as transition_out, I as destroy_each, J as destroy_component, K as set_style } from './client.7dfa8c95.js';
import { f as fly } from './index.ff7bd4a9.js';

/* src/components/Button.svelte generated by Svelte v3.24.1 */

const file = "src/components/Button.svelte";

function create_fragment(ctx) {
	let div;
	let a;
	let t0;
	let t1;
	let label;
	let input;
	let input_value_value;
	let t2;
	let svg;
	let path;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			a = element("a");
			t0 = text("Open map");
			t1 = space();
			label = element("label");
			input = element("input");
			t2 = space();
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			a = claim_element(div_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, "Open map");
			a_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			label = claim_element(div_nodes, "LABEL", { class: true });
			var label_nodes = children(label);

			input = claim_element(label_nodes, "INPUT", {
				type: true,
				value: true,
				name: true,
				"aria-pressed": true,
				class: true
			});

			t2 = claim_space(label_nodes);

			svg = claim_element(
				label_nodes,
				"svg",
				{
					xmlns: true,
					width: true,
					height: true,
					viewBox: true,
					fill: true,
					stroke: true,
					"stroke-width": true,
					"stroke-linecap": true,
					"stroke-linejoin": true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			path = claim_element(svg_nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			label_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", /*link*/ ctx[2]);
			attr_dev(a, "class", "svelte-1nryng2");
			add_location(a, file, 112, 1, 2297);
			attr_dev(input, "type", "checkbox");
			input.__value = input_value_value = /*adhoc*/ ctx[1].id;
			input.value = input.__value;
			attr_dev(input, "name", "save");
			attr_dev(input, "aria-pressed", "false");
			attr_dev(input, "class", "svelte-1nryng2");
			add_location(input, file, 114, 2, 2336);
			attr_dev(path, "d", "M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z");
			add_location(path, file, 122, 179, 2692);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "24");
			attr_dev(svg, "height", "24");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "stroke", "#000000");
			attr_dev(svg, "stroke-width", "2");
			attr_dev(svg, "stroke-linecap", "round");
			attr_dev(svg, "stroke-linejoin", "round");
			attr_dev(svg, "class", "svelte-1nryng2");
			add_location(svg, file, 122, 3, 2516);
			attr_dev(label, "class", "svelte-1nryng2");
			add_location(label, file, 113, 1, 2326);
			attr_dev(div, "class", "svelte-1nryng2");
			add_location(div, file, 111, 0, 2290);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, a);
			append_dev(a, t0);
			append_dev(div, t1);
			append_dev(div, label);
			append_dev(label, input);
			input.checked = /*state*/ ctx[0];
			append_dev(label, t2);
			append_dev(label, svg);
			append_dev(svg, path);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_handler*/ ctx[4], false, false, false),
					listen_dev(
						input,
						"click",
						function () {
							if (is_function(/*pin*/ ctx[3])) /*pin*/ ctx[3].apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(input, "change", /*input_change_handler*/ ctx[5])
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (dirty & /*link*/ 4) {
				attr_dev(a, "href", /*link*/ ctx[2]);
			}

			if (dirty & /*adhoc*/ 2 && input_value_value !== (input_value_value = /*adhoc*/ ctx[1].id)) {
				prop_dev(input, "__value", input_value_value);
				input.value = input.__value;
			}

			if (dirty & /*state*/ 1) {
				input.checked = /*state*/ ctx[0];
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { adhoc } = $$props;
	let { link } = $$props;
	let { state = false } = $$props;
	const writable_props = ["adhoc", "link", "state"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Button> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Button", $$slots, []);
	const input_handler = () => navigator.vibrate(10);

	function input_change_handler() {
		state = this.checked;
		($$invalidate(0, state), $$invalidate(1, adhoc));
	}

	$$self.$$set = $$props => {
		if ("adhoc" in $$props) $$invalidate(1, adhoc = $$props.adhoc);
		if ("link" in $$props) $$invalidate(2, link = $$props.link);
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
	};

	$$self.$capture_state = () => ({ adhoc, link, state, pin });

	$$self.$inject_state = $$props => {
		if ("adhoc" in $$props) $$invalidate(1, adhoc = $$props.adhoc);
		if ("link" in $$props) $$invalidate(2, link = $$props.link);
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
		if ("pin" in $$props) $$invalidate(3, pin = $$props.pin);
	};

	let pin;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*adhoc*/ 2) {
			// Check Local Storage
			 (async () => {
				if (typeof window !== "undefined") {
					if (localStorage.getItem(adhoc.id, "Saved")) {
						return $$invalidate(0, state = true);
					} else {
						return $$invalidate(0, state = false);
					}
				}
			})();
		}

		if ($$self.$$.dirty & /*adhoc*/ 2) {
			// Mark Checkbox
			 $$invalidate(3, pin = async () => {
				if (!localStorage.getItem(adhoc.id)) {
					return localStorage.setItem(adhoc.id, "Saved");
				} else {
					return localStorage.removeItem(adhoc.id, "Saved");
				}
			});
		}
	};

	return [state, adhoc, link, pin, input_handler, input_change_handler];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { adhoc: 1, link: 2, state: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*adhoc*/ ctx[1] === undefined && !("adhoc" in props)) {
			console.warn("<Button> was created without expected prop 'adhoc'");
		}

		if (/*link*/ ctx[2] === undefined && !("link" in props)) {
			console.warn("<Button> was created without expected prop 'link'");
		}
	}

	get adhoc() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set adhoc(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get link() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set link(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get state() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set state(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/locations/[uid].svelte generated by Svelte v3.24.1 */
const file$1 = "src/routes/locations/[uid].svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	return child_ctx;
}

// (101:3) {:else}
function create_else_block(ctx) {
	let em;
	let t0;
	let t1_value = /*adhoc*/ ctx[0].type + "";
	let t1;

	const block = {
		c: function create() {
			em = element("em");
			t0 = text("#");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			em = claim_element(nodes, "EM", { style: true });
			var em_nodes = children(em);
			t0 = claim_text(em_nodes, "#");
			t1 = claim_text(em_nodes, t1_value);
			em_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(em, "color", "var(--col-seco)");
			add_location(em, file$1, 101, 4, 2076);
		},
		m: function mount(target, anchor) {
			insert_dev(target, em, anchor);
			append_dev(em, t0);
			append_dev(em, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*adhoc*/ 1 && t1_value !== (t1_value = /*adhoc*/ ctx[0].type + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(em);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(101:3) {:else}",
		ctx
	});

	return block;
}

// (99:3) {#if adhoc.type === "designer"}
function create_if_block_5(ctx) {
	let em;
	let t0;
	let t1_value = /*adhoc*/ ctx[0].type + "";
	let t1;

	const block = {
		c: function create() {
			em = element("em");
			t0 = text("#");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			em = claim_element(nodes, "EM", { style: true });
			var em_nodes = children(em);
			t0 = claim_text(em_nodes, "#");
			t1 = claim_text(em_nodes, t1_value);
			em_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(em, "color", "var(--col-tert)");
			add_location(em, file$1, 99, 4, 2007);
		},
		m: function mount(target, anchor) {
			insert_dev(target, em, anchor);
			append_dev(em, t0);
			append_dev(em, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*adhoc*/ 1 && t1_value !== (t1_value = /*adhoc*/ ctx[0].type + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(em);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(99:3) {#if adhoc.type === \\\"designer\\\"}",
		ctx
	});

	return block;
}

// (137:3) {#if adhoc.phone != null}
function create_if_block_4(ctx) {
	let t_value = /*adhoc*/ ctx[0].phone + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*adhoc*/ 1 && t_value !== (t_value = /*adhoc*/ ctx[0].phone + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(137:3) {#if adhoc.phone != null}",
		ctx
	});

	return block;
}

// (152:29) 
function create_if_block_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Toilet");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Toilet");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(152:29) ",
		ctx
	});

	return block;
}

// (150:31) 
function create_if_block_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Pets allowed");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Pets allowed");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(150:31) ",
		ctx
	});

	return block;
}

// (148:30) 
function create_if_block_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Paid services");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Paid services");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(148:30) ",
		ctx
	});

	return block;
}

// (146:5) {#if icon === "water"}
function create_if_block(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Water source");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Water source");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(146:5) {#if icon === \\\"water\\\"}",
		ctx
	});

	return block;
}

// (143:3) {#each adhoc.tags as icon}
function create_each_block(ctx) {
	let li;
	let svg;
	let use;
	let use_xlink_href_value;
	let t0;
	let t1;

	function select_block_type_1(ctx, dirty) {
		if (/*icon*/ ctx[3] === "water") return create_if_block;
		if (/*icon*/ ctx[3] === "fee") return create_if_block_1;
		if (/*icon*/ ctx[3] === "pets") return create_if_block_2;
		if (/*icon*/ ctx[3] === "wc") return create_if_block_3;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	const block = {
		c: function create() {
			li = element("li");
			svg = svg_element("svg");
			use = svg_element("use");
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			svg = claim_element(li_nodes, "svg", { class: true }, 1);
			var svg_nodes = children(svg);
			use = claim_element(svg_nodes, "use", { "xlink:href": true }, 1);
			children(use).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			t0 = claim_space(li_nodes);
			if (if_block) if_block.l(li_nodes);
			t1 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			xlink_attr(use, "xlink:href", use_xlink_href_value = "/sprite.svg#" + /*icon*/ ctx[3]);
			add_location(use, file$1, 144, 10, 3871);
			attr_dev(svg, "class", "svelte-1ab2duq");
			add_location(svg, file$1, 144, 5, 3866);
			attr_dev(li, "class", "svelte-1ab2duq");
			add_location(li, file$1, 143, 4, 3856);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, svg);
			append_dev(svg, use);
			append_dev(li, t0);
			if (if_block) if_block.m(li, null);
			append_dev(li, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*adhoc*/ 1 && use_xlink_href_value !== (use_xlink_href_value = "/sprite.svg#" + /*icon*/ ctx[3])) {
				xlink_attr(use, "xlink:href", use_xlink_href_value);
			}

			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(li, t1);
				}
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);

			if (if_block) {
				if_block.d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(143:3) {#each adhoc.tags as icon}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let title_value;
	let t0;
	let div;
	let section;
	let header;
	let t1;
	let h2;
	let t2_value = /*adhoc*/ ctx[0].title + "";
	let t2;
	let t3;
	let dl;
	let dt;
	let t4_value = /*adhoc*/ ctx[0].author + "";
	let t4;
	let dd;
	let t5_value = /*adhoc*/ ctx[0].city + "";
	let t5;
	let t6;
	let t7_value = /*adhoc*/ ctx[0].country + "";
	let t7;
	let t8;
	let p;
	let t9;
	let t10;
	let hr0;
	let t11;
	let address;
	let t12_value = /*adhoc*/ ctx[0].email + "";
	let t12;
	let t13;
	let br;
	let t14;
	let t15;
	let hr1;
	let t16;
	let ul;
	let t17;
	let button;
	let div_intro;
	let current;
	document.title = title_value = /*adhoc*/ ctx[0].title;

	function select_block_type(ctx, dirty) {
		if (/*adhoc*/ ctx[0].type === "designer") return create_if_block_5;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*adhoc*/ ctx[0].phone != null && create_if_block_4(ctx);
	let each_value = /*adhoc*/ ctx[0].tags;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	button = new Button({
			props: {
				adhoc: /*adhoc*/ ctx[0],
				link: /*link*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			div = element("div");
			section = element("section");
			header = element("header");
			if_block0.c();
			t1 = space();
			h2 = element("h2");
			t2 = text(t2_value);
			t3 = space();
			dl = element("dl");
			dt = element("dt");
			t4 = text(t4_value);
			dd = element("dd");
			t5 = text(t5_value);
			t6 = text(", ");
			t7 = text(t7_value);
			t8 = space();
			p = element("p");
			t9 = text("Voluptate ea aliquip nisi consequat ipsum ipsum enim non Lorem.\n\t\t\tNulla ullamco ut nostrud Lorem quis officia dolore adipisicing.\n\t\t\tEx Lorem officia reprehenderit velit aute voluptate aliquip\n\t\t\texercitation in. Nulla anim ex amet do aliqua sunt laborum anim\n\t\t\tad. Cupidatat voluptate deserunt sint elit ipsum aliquip aliquip\n\t\t\texcepteur. Elit irure sunt eu proident sit. Consectetur in\n\t\t\tconsectetur ex sint exercitation enim amet laboris nisi. Cillum\n\t\t\tesse non ut id quis aliquip duis amet officia eu irure aliquip\n\t\t\tsint quis. Magna voluptate dolor in esse aliqua esse adipisicing\n\t\t\tcommodo. Amet laboris id sit pariatur labore nostrud laborum\n\t\t\tvelit exercitation ea veniam minim mollit duis. Voluptate ea aliquip nisi consequat ipsum ipsum enim non Lorem.\n\t\t\tNulla ullamco ut nostrud Lorem quis officia dolore adipisicing.\n\t\t\tEx Lorem officia reprehenderit velit aute voluptate aliquip\n\t\t\texercitation in. Nulla anim ex amet do aliqua sunt laborum anim\n\t\t\tad. Cupidatat voluptate deserunt sint elit ipsum aliquip aliquip\n\t\t\texcepteur. Elit irure sunt eu proident sit. Consectetur in\n\t\t\tconsectetur ex sint exercitation enim amet laboris nisi. Cillum\n\t\t\tesse non ut id quis aliquip duis amet officia eu irure aliquip\n\t\t\tsint quis. Magna voluptate dolor in esse aliqua esse adipisicing\n\t\t\tcommodo. Amet laboris id sit pariatur labore nostrud laborum\n\t\t\tvelit exercitation ea veniam minim mollit duis.");
			t10 = space();
			hr0 = element("hr");
			t11 = space();
			address = element("address");
			t12 = text(t12_value);
			t13 = space();
			br = element("br");
			t14 = space();
			if (if_block1) if_block1.c();
			t15 = space();
			hr1 = element("hr");
			t16 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t17 = space();
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-w6u6cv\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			section = claim_element(div_nodes, "SECTION", {});
			var section_nodes = children(section);
			header = claim_element(section_nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			if_block0.l(header_nodes);
			t1 = claim_space(header_nodes);
			h2 = claim_element(header_nodes, "H2", {});
			var h2_nodes = children(h2);
			t2 = claim_text(h2_nodes, t2_value);
			h2_nodes.forEach(detach_dev);
			t3 = claim_space(header_nodes);
			dl = claim_element(header_nodes, "DL", {});
			var dl_nodes = children(dl);
			dt = claim_element(dl_nodes, "DT", { class: true });
			var dt_nodes = children(dt);
			t4 = claim_text(dt_nodes, t4_value);
			dt_nodes.forEach(detach_dev);
			dd = claim_element(dl_nodes, "DD", { class: true });
			var dd_nodes = children(dd);
			t5 = claim_text(dd_nodes, t5_value);
			t6 = claim_text(dd_nodes, ", ");
			t7 = claim_text(dd_nodes, t7_value);
			dd_nodes.forEach(detach_dev);
			dl_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			t8 = claim_space(section_nodes);
			p = claim_element(section_nodes, "P", { class: true });
			var p_nodes = children(p);
			t9 = claim_text(p_nodes, "Voluptate ea aliquip nisi consequat ipsum ipsum enim non Lorem.\n\t\t\tNulla ullamco ut nostrud Lorem quis officia dolore adipisicing.\n\t\t\tEx Lorem officia reprehenderit velit aute voluptate aliquip\n\t\t\texercitation in. Nulla anim ex amet do aliqua sunt laborum anim\n\t\t\tad. Cupidatat voluptate deserunt sint elit ipsum aliquip aliquip\n\t\t\texcepteur. Elit irure sunt eu proident sit. Consectetur in\n\t\t\tconsectetur ex sint exercitation enim amet laboris nisi. Cillum\n\t\t\tesse non ut id quis aliquip duis amet officia eu irure aliquip\n\t\t\tsint quis. Magna voluptate dolor in esse aliqua esse adipisicing\n\t\t\tcommodo. Amet laboris id sit pariatur labore nostrud laborum\n\t\t\tvelit exercitation ea veniam minim mollit duis. Voluptate ea aliquip nisi consequat ipsum ipsum enim non Lorem.\n\t\t\tNulla ullamco ut nostrud Lorem quis officia dolore adipisicing.\n\t\t\tEx Lorem officia reprehenderit velit aute voluptate aliquip\n\t\t\texercitation in. Nulla anim ex amet do aliqua sunt laborum anim\n\t\t\tad. Cupidatat voluptate deserunt sint elit ipsum aliquip aliquip\n\t\t\texcepteur. Elit irure sunt eu proident sit. Consectetur in\n\t\t\tconsectetur ex sint exercitation enim amet laboris nisi. Cillum\n\t\t\tesse non ut id quis aliquip duis amet officia eu irure aliquip\n\t\t\tsint quis. Magna voluptate dolor in esse aliqua esse adipisicing\n\t\t\tcommodo. Amet laboris id sit pariatur labore nostrud laborum\n\t\t\tvelit exercitation ea veniam minim mollit duis.");
			p_nodes.forEach(detach_dev);
			t10 = claim_space(section_nodes);
			hr0 = claim_element(section_nodes, "HR", {});
			t11 = claim_space(section_nodes);
			address = claim_element(section_nodes, "ADDRESS", { class: true });
			var address_nodes = children(address);
			t12 = claim_text(address_nodes, t12_value);
			t13 = claim_space(address_nodes);
			br = claim_element(address_nodes, "BR", {});
			t14 = claim_space(address_nodes);
			if (if_block1) if_block1.l(address_nodes);
			address_nodes.forEach(detach_dev);
			t15 = claim_space(section_nodes);
			hr1 = claim_element(section_nodes, "HR", {});
			t16 = claim_space(section_nodes);
			ul = claim_element(section_nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			t17 = claim_space(div_nodes);
			claim_component(button.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h2, file$1, 103, 3, 2142);
			attr_dev(dt, "class", "svelte-1ab2duq");
			add_location(dt, file$1, 105, 4, 2177);
			attr_dev(dd, "class", "svelte-1ab2duq");
			add_location(dd, file$1, 106, 4, 2205);
			add_location(dl, file$1, 104, 3, 2168);
			attr_dev(header, "class", "svelte-1ab2duq");
			add_location(header, file$1, 97, 2, 1959);
			attr_dev(p, "class", "svelte-1ab2duq");
			add_location(p, file$1, 109, 2, 2267);
			add_location(hr0, file$1, 132, 2, 3697);
			add_location(br, file$1, 135, 3, 3734);
			attr_dev(address, "class", "svelte-1ab2duq");
			add_location(address, file$1, 133, 2, 3704);
			add_location(hr1, file$1, 140, 2, 3810);
			attr_dev(ul, "class", "svelte-1ab2duq");
			add_location(ul, file$1, 141, 2, 3817);
			add_location(section, file$1, 96, 1, 1947);
			attr_dev(div, "class", "svelte-1ab2duq");
			add_location(div, file$1, 95, 0, 1894);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, section);
			append_dev(section, header);
			if_block0.m(header, null);
			append_dev(header, t1);
			append_dev(header, h2);
			append_dev(h2, t2);
			append_dev(header, t3);
			append_dev(header, dl);
			append_dev(dl, dt);
			append_dev(dt, t4);
			append_dev(dl, dd);
			append_dev(dd, t5);
			append_dev(dd, t6);
			append_dev(dd, t7);
			append_dev(section, t8);
			append_dev(section, p);
			append_dev(p, t9);
			append_dev(section, t10);
			append_dev(section, hr0);
			append_dev(section, t11);
			append_dev(section, address);
			append_dev(address, t12);
			append_dev(address, t13);
			append_dev(address, br);
			append_dev(address, t14);
			if (if_block1) if_block1.m(address, null);
			append_dev(section, t15);
			append_dev(section, hr1);
			append_dev(section, t16);
			append_dev(section, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append_dev(div, t17);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*adhoc*/ 1) && title_value !== (title_value = /*adhoc*/ ctx[0].title)) {
				document.title = title_value;
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(header, t1);
				}
			}

			if ((!current || dirty & /*adhoc*/ 1) && t2_value !== (t2_value = /*adhoc*/ ctx[0].title + "")) set_data_dev(t2, t2_value);
			if ((!current || dirty & /*adhoc*/ 1) && t4_value !== (t4_value = /*adhoc*/ ctx[0].author + "")) set_data_dev(t4, t4_value);
			if ((!current || dirty & /*adhoc*/ 1) && t5_value !== (t5_value = /*adhoc*/ ctx[0].city + "")) set_data_dev(t5, t5_value);
			if ((!current || dirty & /*adhoc*/ 1) && t7_value !== (t7_value = /*adhoc*/ ctx[0].country + "")) set_data_dev(t7, t7_value);
			if ((!current || dirty & /*adhoc*/ 1) && t12_value !== (t12_value = /*adhoc*/ ctx[0].email + "")) set_data_dev(t12, t12_value);

			if (/*adhoc*/ ctx[0].phone != null) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_4(ctx);
					if_block1.c();
					if_block1.m(address, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*adhoc*/ 1) {
				each_value = /*adhoc*/ ctx[0].tags;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			const button_changes = {};
			if (dirty & /*adhoc*/ 1) button_changes.adhoc = /*adhoc*/ ctx[0];
			if (dirty & /*link*/ 2) button_changes.link = /*link*/ ctx[1];
			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);

			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fly, { duration: 320, y: 40, opacity: 1 });
					div_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if_block0.d();
			if (if_block1) if_block1.d();
			destroy_each(each_blocks, detaching);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload(page, session) {
	// URL + ID
	const { uid } = page.params;

	const url = "https://6016e904f534300017a4509d.mockapi.io/board/" + uid;

	// Fetch
	const res = await this.fetch(url);

	// Validate
	if (res.status === 200) {
		const adhoc = await res.json();
		return { adhoc };
	}

	// Error
	this.error(500, "Problems with server. Be right back soon ;)");
}

function instance$1($$self, $$props, $$invalidate) {
	let { adhoc } = $$props;
	let { link = "javascript:;" } = $$props;

	// Back
	const historyback = () => {
		if (typeof window !== "undefined") {
			window.history.back();
		}
	};

	const writable_props = ["adhoc", "link"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<U5Buidu5D> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("U5Buidu5D", $$slots, []);

	$$self.$$set = $$props => {
		if ("adhoc" in $$props) $$invalidate(0, adhoc = $$props.adhoc);
		if ("link" in $$props) $$invalidate(1, link = $$props.link);
	};

	$$self.$capture_state = () => ({
		preload,
		fly,
		Button,
		adhoc,
		link,
		historyback
	});

	$$self.$inject_state = $$props => {
		if ("adhoc" in $$props) $$invalidate(0, adhoc = $$props.adhoc);
		if ("link" in $$props) $$invalidate(1, link = $$props.link);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [adhoc, link];
}

class U5Buidu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, not_equal, { adhoc: 0, link: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Buidu5D",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*adhoc*/ ctx[0] === undefined && !("adhoc" in props)) {
			console.warn("<U5Buidu5D> was created without expected prop 'adhoc'");
		}
	}

	get adhoc() {
		throw new Error("<U5Buidu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set adhoc(value) {
		throw new Error("<U5Buidu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get link() {
		throw new Error("<U5Buidu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set link(value) {
		throw new Error("<U5Buidu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default U5Buidu5D;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiW3VpZF0uNzM1NDhlZDMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0J1dHRvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2xvY2F0aW9ucy9bdWlkXS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cblx0Ly8gRXhwb3J0ZWRcblx0ZXhwb3J0IGxldCBhZGhvYztcblx0ZXhwb3J0IGxldCBsaW5rO1xuXHRleHBvcnQgbGV0IHN0YXRlID0gZmFsc2U7XG5cblx0Ly8gQ2hlY2sgTG9jYWwgU3RvcmFnZVxuXHQkOiAoYXN5bmMoKSA9PiB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShhZGhvYy5pZCwgXCJTYXZlZFwiKSkge1xuXHRcdFx0XHRyZXR1cm4gc3RhdGUgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHN0YXRlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KSgpO1xuXG5cdC8vIE1hcmsgQ2hlY2tib3hcblx0JDogcGluID0gYXN5bmMgKCkgPT4ge1xuXHRcdGlmICghbG9jYWxTdG9yYWdlLmdldEl0ZW0oYWRob2MuaWQpKSB7XG5cdFx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oYWRob2MuaWQsIFwiU2F2ZWRcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShhZGhvYy5pZCwgXCJTYXZlZFwiKTtcblx0XHR9XG5cdH07XG48L3NjcmlwdD5cblxuPCEtLSBDU1MgLS0+XG48c3R5bGU+XG5cdGRpdiB7XG5cdFx0LyogRGlzcGxheSAqL1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IHJvdztcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cdFx0LyogU2l6aW5nICovXG5cdFx0bWluLWhlaWdodDogY2FsYygxMHZoICsgKHZhcigtLXB0KSAqIDIpKTtcblx0XHRtYXgtaGVpZ2h0OiBjYWxjKDEwdmggKyAodmFyKC0tcHQpICogMikpO1xuXHRcdGhlaWdodDogY2FsYygxMHZoICsgKHZhcigtLXB0KSAqIDIpKTtcblx0XHRtaW4td2lkdGg6IDEwMCU7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdC8qIFBvc2l0aW9uICovXG5cdFx0cG9zaXRpb246IHN0aWNreTtcblx0XHRwb3NpdGlvbjogLXdlYmtpdC1zdGlja3k7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdC8qIFJlc3QgKi9cblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2wtcHJpbWUpO1xuXHRcdGJvcmRlci10b3A6IDJweCBzb2xpZCB2YXIoLS1jb2wtcHJpbWVsaWdodCk7XG5cdFx0cGFkZGluZzogY2FsYyh2YXIoLS1wdCkgKiAyKSBjYWxjKHZhcigtLXB0KSAqIDMpO1xuXHR9XG5cdGEsIGxhYmVsIHtcblx0XHQvKiBEaXNwbGF5ICovXG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogcm93O1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0YWxpZ24tY29udGVudDogY2VudGVyO1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHR9XG5cdGEge1xuXHRcdC8qIFNpemluZyAqL1xuXHRcdG1pbi1oZWlnaHQ6IDEwMCU7XG5cdFx0bWF4LWhlaWdodDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0bWluLXdpZHRoOiA3MHZ3O1xuXHRcdG1heC13aWR0aDogNzB2dztcblx0XHR3aWR0aDogMTAwJTtcblx0XHQvKiBSZXN0ICovXG5cdFx0Ym9yZGVyLXJhZGl1czogdmFyKC0tcHQpO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbC1zZWNvKTtcblx0XHRjb2xvcjogdmFyKC0tY29sLXByaW1lKTtcblx0XHRtYXJnaW4tcmlnaHQ6IHZhcigtLXB0KTtcblx0fVxuXHRsYWJlbCB7XG5cdFx0LyogU2l6aW5nICovXG5cdFx0bWluLWhlaWdodDogMTAwJTtcblx0XHRtYXgtaGVpZ2h0OiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRtaW4td2lkdGg6IG5vbmU7XG5cdFx0bWF4LXdpZHRoOiBub25lO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdC8qIFJlc3QgKi9cblx0XHRib3JkZXItcmFkaXVzOiB2YXIoLS1wdCk7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sLXByaW1lbGlnaHQpO1xuXHR9XG5cdGlucHV0W3R5cGU9Y2hlY2tib3hdIHtcblx0XHQtbW96LWFwcGVhcmFuY2U6IG5vbmU7XG5cdFx0LXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuXHRcdGFwcGVhcmFuY2U6IG5vbmU7XG5cdFx0ZGlzcGxheTogbm9uZTtcblx0fVxuXHRpbnB1dFt0eXBlPWNoZWNrYm94XTpjaGVja2VkIH4gc3ZnIHtcblx0XHRmaWxsOiB2YXIoLS1jb2wtYmxhY2spO1xuXHR9XG5cdHN2ZyB7XG4gICAgICAgIC8qIFNpemluZyAqL1xuXHRcdG1pbi1oZWlnaHQ6IGNhbGModmFyKC0tcHQpICogMi41KTtcblx0XHRtYXgtaGVpZ2h0OiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG5cdFx0aGVpZ2h0OiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG5cdFx0bWluLXdpZHRoOiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG5cdFx0bWF4LXdpZHRoOiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG4gICAgICAgIHdpZHRoOiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG4gICAgICAgIC8qIFJlc3QgKi9cbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1jb2wtYmxhY2spO1xuICAgICAgICBzdHJva2Utd2lkdGg6IDI7XG5cdFx0ZmlsbDogbm9uZTtcbiAgICB9XG48L3N0eWxlPlxuXG48IS0tIEhUTUwgLS0+XG48ZGl2PlxuXHQ8YSBocmVmPXtsaW5rfT5PcGVuIG1hcDwvYT5cblx0PGxhYmVsPlxuXHRcdDxpbnB1dFxuXHRcdFx0b246aW5wdXQ9eygpID0+IG5hdmlnYXRvci52aWJyYXRlKDEwKX1cblx0XHRcdG9uOmNsaWNrPXtwaW59IFxuXHRcdFx0YmluZDpjaGVja2VkPXtzdGF0ZX0gXG5cdFx0XHR0eXBlPVwiY2hlY2tib3hcIiBcblx0XHRcdHZhbHVlPXthZGhvYy5pZH0gXG5cdFx0XHRuYW1lPVwic2F2ZVwiIFxuXHRcdFx0YXJpYS1wcmVzc2VkPVwiZmFsc2VcIiAvPlxuXHRcdFx0PHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiIzAwMDAwMFwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cGF0aCBkPVwiTTE5IDIxbC03LTUtNyA1VjVhMiAyIDAgMCAxIDItMmgxMGEyIDIgMCAwIDEgMiAyelwiPjwvcGF0aD48L3N2Zz5cblx0PC9sYWJlbD5cbjwvZGl2PiIsIjwhLS0gU2VydmVyIC0tPlxuPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG5cdGV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVsb2FkKHBhZ2UsIHNlc3Npb24pIHtcblx0XHQvLyBVUkwgKyBJRFxuXHRcdGNvbnN0IHsgdWlkIH0gPSBwYWdlLnBhcmFtcztcblx0XHRjb25zdCB1cmwgPSBcImh0dHBzOi8vNjAxNmU5MDRmNTM0MzAwMDE3YTQ1MDlkLm1vY2thcGkuaW8vYm9hcmQvXCIgKyB1aWQ7XG5cdFx0Ly8gRmV0Y2hcblx0XHRjb25zdCByZXMgPSBhd2FpdCB0aGlzLmZldGNoKHVybCk7XG5cdFx0Ly8gVmFsaWRhdGVcblx0XHRpZiAocmVzLnN0YXR1cyA9PT0gMjAwKSB7XG5cdFx0XHRjb25zdCBhZGhvYyA9IGF3YWl0IHJlcy5qc29uKCk7XG5cdFx0XHRyZXR1cm4geyBhZGhvYyB9O1xuXHRcdH1cblx0XHQvLyBFcnJvclxuXHRcdHRoaXMuZXJyb3IoNTAwLCBcIlByb2JsZW1zIHdpdGggc2VydmVyLiBCZSByaWdodCBiYWNrIHNvb24gOylcIik7XG5cdH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0PlxuXHRpbXBvcnQgeyBmbHkgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcblx0aW1wb3J0IEJ1dHRvbiBmcm9tIFwiLi4vLi4vY29tcG9uZW50cy9CdXR0b24uc3ZlbHRlXCI7XG5cblx0Ly8gRXhwb3J0ZWRcblx0ZXhwb3J0IGxldCBhZGhvYztcblx0ZXhwb3J0IGxldCBsaW5rID0gXCJqYXZhc2NyaXB0OjtcIjtcblxuXHQvLyBCYWNrXG5cdGNvbnN0IGhpc3RvcnliYWNrID0gKCkgPT4ge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG5cdFx0fVxuXHR9O1xuPC9zY3JpcHQ+XG5cbjwhLS0gU3BlY2lhbCAtLT5cbjxzdmVsdGU6aGVhZD5cblx0PHRpdGxlPnthZGhvYy50aXRsZX08L3RpdGxlPlxuPC9zdmVsdGU6aGVhZD5cbjxzdmVsdGU6b3B0aW9ucyBpbW11dGFibGUgLz5cblxuPCEtLSBDU1MgLS0+XG48c3R5bGU+XG5cdGRpdiB7XG5cdFx0LyogRGlzcGxheSAqL1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG5cdFx0LyogUmVzdCAqL1xuXHRcdHBhZGRpbmctdG9wOiBjYWxjKHZhcigtLXB0KSAqIDEuNSk7XG5cdH1cblx0aGVhZGVyIHtcblx0XHRwYWRkaW5nOiBjYWxjKHZhcigtLXB0KSAqIDMpIGNhbGModmFyKC0tcHQpICogMykgMDtcblx0fVxuXHRwIHtcblx0XHRwYWRkaW5nOiBjYWxjKHZhcigtLXB0KSAqIDMpO1xuXHR9XG5cdHVsIHtcblx0XHRwYWRkaW5nOiBjYWxjKHZhcigtLXB0KSAqIDIpIGNhbGModmFyKC0tcHQpICogMyk7XG5cdH1cblx0bGkge1xuXHRcdC8qIERpc3BsYXkgKi9cblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGZsZXgtZGlyZWN0aW9uOiByb3c7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRhbGlnbi1jb250ZW50OiBjZW50ZXI7XG5cdFx0anVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuXHRcdC8qIFJlc3QgKi9cblx0XHRwYWRkaW5nOiB2YXIoLS1wdCkgMDtcblx0fVxuXHRzdmcge1xuICAgICAgICAvKiBTaXppbmcgKi9cblx0XHRtaW4taGVpZ2h0OiBjYWxjKHZhcigtLXB0KSAqIDIuNSk7XG5cdFx0bWF4LWhlaWdodDogY2FsYyh2YXIoLS1wdCkgKiAyLjUpO1xuXHRcdGhlaWdodDogY2FsYyh2YXIoLS1wdCkgKiAyLjUpO1xuXHRcdG1pbi13aWR0aDogY2FsYyh2YXIoLS1wdCkgKiAyLjUpO1xuXHRcdG1heC13aWR0aDogY2FsYyh2YXIoLS1wdCkgKiAyLjUpO1xuICAgICAgICB3aWR0aDogY2FsYyh2YXIoLS1wdCkgKiAyLjUpO1xuICAgICAgICAvKiBSZXN0ICovXG4gICAgICAgIHN0cm9rZTogdmFyKC0tY29sLWJsYWNrKTtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAyO1xuXHRcdGZpbGw6IG5vbmU7XG5cdFx0bWFyZ2luLXJpZ2h0OiB2YXIoLS1wdCk7XG5cdH1cblx0LyogRm9udHMgKi9cblx0ZHQsIHAsIGFkZHJlc3Mge1xuXHRcdGZvbnQtc2l6ZTogMXJlbTtcblx0fVxuXHRkZCB7XG5cdFx0Zm9udC1zaXplOiAuOXJlbTtcblx0fVxuPC9zdHlsZT5cblxuPCEtLSBIVE1MIC0tPlxuPGRpdiBpbjpmbHk9e3sgZHVyYXRpb246IDMyMCwgeTogNDAsIG9wYWNpdHk6IDEgfX0+XG5cdDxzZWN0aW9uPlxuXHRcdDxoZWFkZXI+XG5cdFx0XHR7I2lmIGFkaG9jLnR5cGUgPT09IFwiZGVzaWduZXJcIn1cblx0XHRcdFx0PGVtIHN0eWxlPVwiY29sb3I6IHZhcigtLWNvbC10ZXJ0KVwiPiN7YWRob2MudHlwZX08L2VtPlxuXHRcdFx0ezplbHNlfVxuXHRcdFx0XHQ8ZW0gc3R5bGU9XCJjb2xvcjogdmFyKC0tY29sLXNlY28pXCI+I3thZGhvYy50eXBlfTwvZW0+XG5cdFx0XHR7L2lmfVxuXHRcdFx0PGgyPnthZGhvYy50aXRsZX08L2gyPlxuXHRcdFx0PGRsPlxuXHRcdFx0XHQ8ZHQ+e2FkaG9jLmF1dGhvcn08L2R0PlxuXHRcdFx0XHQ8ZGQ+e2FkaG9jLmNpdHl9LCB7YWRob2MuY291bnRyeX08L2RkPlxuXHRcdFx0PC9kbD5cblx0XHQ8L2hlYWRlcj5cblx0XHQ8cD5cblx0XHRcdFZvbHVwdGF0ZSBlYSBhbGlxdWlwIG5pc2kgY29uc2VxdWF0IGlwc3VtIGlwc3VtIGVuaW0gbm9uIExvcmVtLlxuXHRcdFx0TnVsbGEgdWxsYW1jbyB1dCBub3N0cnVkIExvcmVtIHF1aXMgb2ZmaWNpYSBkb2xvcmUgYWRpcGlzaWNpbmcuXG5cdFx0XHRFeCBMb3JlbSBvZmZpY2lhIHJlcHJlaGVuZGVyaXQgdmVsaXQgYXV0ZSB2b2x1cHRhdGUgYWxpcXVpcFxuXHRcdFx0ZXhlcmNpdGF0aW9uIGluLiBOdWxsYSBhbmltIGV4IGFtZXQgZG8gYWxpcXVhIHN1bnQgbGFib3J1bSBhbmltXG5cdFx0XHRhZC4gQ3VwaWRhdGF0IHZvbHVwdGF0ZSBkZXNlcnVudCBzaW50IGVsaXQgaXBzdW0gYWxpcXVpcCBhbGlxdWlwXG5cdFx0XHRleGNlcHRldXIuIEVsaXQgaXJ1cmUgc3VudCBldSBwcm9pZGVudCBzaXQuIENvbnNlY3RldHVyIGluXG5cdFx0XHRjb25zZWN0ZXR1ciBleCBzaW50IGV4ZXJjaXRhdGlvbiBlbmltIGFtZXQgbGFib3JpcyBuaXNpLiBDaWxsdW1cblx0XHRcdGVzc2Ugbm9uIHV0IGlkIHF1aXMgYWxpcXVpcCBkdWlzIGFtZXQgb2ZmaWNpYSBldSBpcnVyZSBhbGlxdWlwXG5cdFx0XHRzaW50IHF1aXMuIE1hZ25hIHZvbHVwdGF0ZSBkb2xvciBpbiBlc3NlIGFsaXF1YSBlc3NlIGFkaXBpc2ljaW5nXG5cdFx0XHRjb21tb2RvLiBBbWV0IGxhYm9yaXMgaWQgc2l0IHBhcmlhdHVyIGxhYm9yZSBub3N0cnVkIGxhYm9ydW1cblx0XHRcdHZlbGl0IGV4ZXJjaXRhdGlvbiBlYSB2ZW5pYW0gbWluaW0gbW9sbGl0IGR1aXMuIFZvbHVwdGF0ZSBlYSBhbGlxdWlwIG5pc2kgY29uc2VxdWF0IGlwc3VtIGlwc3VtIGVuaW0gbm9uIExvcmVtLlxuXHRcdFx0TnVsbGEgdWxsYW1jbyB1dCBub3N0cnVkIExvcmVtIHF1aXMgb2ZmaWNpYSBkb2xvcmUgYWRpcGlzaWNpbmcuXG5cdFx0XHRFeCBMb3JlbSBvZmZpY2lhIHJlcHJlaGVuZGVyaXQgdmVsaXQgYXV0ZSB2b2x1cHRhdGUgYWxpcXVpcFxuXHRcdFx0ZXhlcmNpdGF0aW9uIGluLiBOdWxsYSBhbmltIGV4IGFtZXQgZG8gYWxpcXVhIHN1bnQgbGFib3J1bSBhbmltXG5cdFx0XHRhZC4gQ3VwaWRhdGF0IHZvbHVwdGF0ZSBkZXNlcnVudCBzaW50IGVsaXQgaXBzdW0gYWxpcXVpcCBhbGlxdWlwXG5cdFx0XHRleGNlcHRldXIuIEVsaXQgaXJ1cmUgc3VudCBldSBwcm9pZGVudCBzaXQuIENvbnNlY3RldHVyIGluXG5cdFx0XHRjb25zZWN0ZXR1ciBleCBzaW50IGV4ZXJjaXRhdGlvbiBlbmltIGFtZXQgbGFib3JpcyBuaXNpLiBDaWxsdW1cblx0XHRcdGVzc2Ugbm9uIHV0IGlkIHF1aXMgYWxpcXVpcCBkdWlzIGFtZXQgb2ZmaWNpYSBldSBpcnVyZSBhbGlxdWlwXG5cdFx0XHRzaW50IHF1aXMuIE1hZ25hIHZvbHVwdGF0ZSBkb2xvciBpbiBlc3NlIGFsaXF1YSBlc3NlIGFkaXBpc2ljaW5nXG5cdFx0XHRjb21tb2RvLiBBbWV0IGxhYm9yaXMgaWQgc2l0IHBhcmlhdHVyIGxhYm9yZSBub3N0cnVkIGxhYm9ydW1cblx0XHRcdHZlbGl0IGV4ZXJjaXRhdGlvbiBlYSB2ZW5pYW0gbWluaW0gbW9sbGl0IGR1aXMuXG5cdFx0PC9wPlxuXHRcdDxocj5cblx0XHQ8YWRkcmVzcz5cblx0XHRcdHthZGhvYy5lbWFpbH1cblx0XHRcdDxicj5cblx0XHRcdHsjaWYgYWRob2MucGhvbmUgIT0gbnVsbH1cblx0XHRcdFx0e2FkaG9jLnBob25lfVxuXHRcdFx0ey9pZn1cblx0XHQ8L2FkZHJlc3M+XG5cdFx0PGhyPlxuXHRcdDx1bD5cblx0XHRcdHsjZWFjaCBhZGhvYy50YWdzIGFzIGljb259XG5cdFx0XHRcdDxsaT5cblx0XHRcdFx0XHQ8c3ZnPjx1c2UgeGxpbms6aHJlZj1cIi9zcHJpdGUuc3ZnI3tpY29ufVwiIC8+PC9zdmc+XG5cdFx0XHRcdFx0eyNpZiBpY29uID09PSBcIndhdGVyXCJ9XG5cdFx0XHRcdFx0XHRXYXRlciBzb3VyY2Vcblx0XHRcdFx0XHR7OmVsc2UgaWYgaWNvbiA9PT0gXCJmZWVcIn1cblx0XHRcdFx0XHRcdFBhaWQgc2VydmljZXNcblx0XHRcdFx0XHR7OmVsc2UgaWYgaWNvbiA9PT0gXCJwZXRzXCJ9XG5cdFx0XHRcdFx0XHRQZXRzIGFsbG93ZWRcblx0XHRcdFx0XHR7OmVsc2UgaWYgaWNvbiA9PT0gXCJ3Y1wifVxuXHRcdFx0XHRcdFx0VG9pbGV0XG5cdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0PC9saT5cblx0XHRcdHsvZWFjaH1cblx0XHQ8L3VsPlxuXHQ8L3NlY3Rpb24+XG5cdDwhLS0gQ1RBJ3MgLS0+XG5cdDxCdXR0b24ge2FkaG9jfSB7bGlua30vPlxuPC9kaXY+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQ0FnSFUsR0FBSTs7OztpREFPSixHQUFLLElBQUMsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkFGRCxHQUFLOzs7Ozs7Ozs7Ozs7K0JBRFQsR0FBRyxjQUFILEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7aUNBSk4sR0FBSTs7O21GQU9KLEdBQUssSUFBQyxFQUFFOzs7Ozs7OEJBRkQsR0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbkhWLEtBQUs7T0FDTCxJQUFJO09BQ0osS0FBSyxHQUFHLEtBQUs7Ozs7Ozs7Ozs2QkErR04sU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFOzs7RUFFdEIsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUE3R1QsTUFBTSxLQUFLLFdBQVc7U0FDNUIsWUFBWSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLE9BQU87NkJBQ2xDLEtBQUssR0FBRyxJQUFJOzs2QkFFWixLQUFLLEdBQUcsS0FBSzs7Ozs7Ozs7b0JBTXBCLEdBQUc7U0FDQSxZQUFZLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzFCLFlBQVksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxPQUFPOztZQUV0QyxZQUFZLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJDK0VWLEdBQUssSUFBQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lFQUFWLEdBQUssSUFBQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQUZWLEdBQUssSUFBQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lFQUFWLEdBQUssSUFBQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkFzQzlDLEdBQUssSUFBQyxLQUFLOzs7Ozs7Ozs7Ozs7OzsrREFBWCxHQUFLLElBQUMsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQVFOLEdBQUksUUFBSyxPQUFPO2VBRVgsR0FBSSxRQUFLLEtBQUs7ZUFFZCxHQUFJLFFBQUssTUFBTTtlQUVmLEdBQUksUUFBSyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tGQVBZLEdBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQUosR0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQXpDcEMsR0FBSyxJQUFDLEtBQUs7Ozs7OzBCQUVWLEdBQUssSUFBQyxNQUFNOzs7MEJBQ1osR0FBSyxJQUFDLElBQUk7OzswQkFBSSxHQUFLLElBQUMsT0FBTzs7Ozs7Ozs7OzJCQTRCaEMsR0FBSyxJQUFDLEtBQUs7Ozs7Ozs7Ozs7Ozs7MENBbEdOLEdBQUssSUFBQyxLQUFLOzs7Z0JBOERaLEdBQUssSUFBQyxJQUFJLEtBQUssVUFBVTs7Ozs7OzJCQXNDekIsR0FBSyxJQUFDLEtBQUssSUFBSSxJQUFJOzRCQU1qQixHQUFLLElBQUMsSUFBSTs7OztnQ0FBZixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FGQTFHQSxHQUFLLElBQUMsS0FBSzs7Ozs7Ozs7Ozs7Ozs7OzsrRUFtRVosR0FBSyxJQUFDLEtBQUs7K0VBRVYsR0FBSyxJQUFDLE1BQU07K0VBQ1osR0FBSyxJQUFDLElBQUk7K0VBQUksR0FBSyxJQUFDLE9BQU87aUZBNEJoQyxHQUFLLElBQUMsS0FBSzs7aUJBRVAsR0FBSyxJQUFDLEtBQUssSUFBSSxJQUFJOzs7Ozs7Ozs7Ozs7OzsyQkFNakIsR0FBSyxJQUFDLElBQUk7Ozs7K0JBQWYsTUFBSTs7Ozs7Ozs7Ozs7Ozs7OztvQ0FBSixNQUFJOzs7Ozs7Ozs7Ozs7OztrREEvQ00sUUFBUSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQTdGeEIsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPOztTQUVsQyxHQUFHLEtBQUssSUFBSSxDQUFDLE1BQU07O09BQ3JCLEdBQUcsR0FBRyxvREFBb0QsR0FBRyxHQUFHOzs7T0FFaEUsR0FBRyxTQUFTLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRzs7O0tBRTVCLEdBQUcsQ0FBQyxNQUFNLEtBQUssR0FBRztRQUNmLEtBQUssU0FBUyxHQUFHLENBQUMsSUFBSTtXQUNuQixLQUFLOzs7O0NBR2YsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsNkNBQTZDOzs7O09BU25ELEtBQUs7T0FDTCxJQUFJLEdBQUcsY0FBYzs7O09BRzFCLFdBQVc7YUFDTCxNQUFNLEtBQUssV0FBVztHQUNoQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
